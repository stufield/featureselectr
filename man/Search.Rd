% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Search.R
\name{Search}
\alias{Search}
\title{Feature Selection Search Algorithms}
\usage{
Search(x, num_cores)
}
\arguments{
\item{x}{A \code{feature_select} class object from a call
call to \code{\link[=feature_selection]{feature_selection()}}.}

\item{num_cores}{\code{integer(1)}. How many cores to use during the search.
Defaults to \code{1L}, which does not use parallel processing. Values \verb{> 1}
only available in Linux systems. Note that parallel processing
is implemented on the \emph{runs}(!), so choose the cores appropriately.}
}
\value{
A \code{"feature_select"} class object; a list of:
\item{data}{The original feature data to use.}
\item{candidate_features}{The list of candidate features.}
\item{model_type}{A list containing model type variables of the
appropriate class for the desired model type.}
\item{search_type}{A list containing search type variables of the
appropriate class for the desired search type.}
\item{cost}{A string of the type of cost function.}
\item{cost_fxn}{A list containing cost variables of the
appropriate class for the desired object cost function.}
\item{runs}{The number of runs.}
\item{folds}{The number of folds.}
\item{random_seed}{The random seed used}
\item{cross_val}{A list containing the training and test indices of the
various cross validation folds.}
\item{search_complete}{Logical if the object has completed a search}
\item{call}{The original matched call.}
}
\description{
These step-wise search methods can be used to identify a locally optimal
model complexity through greedy search. The methods either build up
(forward) or break down (backward) a model one covariate at a time based
upon the results of all "Runs" and "Folds" of cross-validation sets, i.e.
for 5 runs of 5-fold cross-validation, 25 evaluations are made to determine
which covariate yields the best average performance (for a given cost
function). See \emph{Details} for more information on options.
}
\details{
There are currently 2 search options, all of which are "greedy" algorithms:

\describe{
\item{Forward Model Search:}{
The covariate found in the first step carries
through to all other steps. Likewise, the second
covariate found (in combination with the first) also
carries through. The results is a single model determined
to be locally optimal based upon the performances across
all runs and folds.}
\item{Backward Model Search:}{
The covariate removed in the first step is
eliminated through all other steps. The result
is a single model determined to be locally optimal
based upon the performances across all runs and folds.}
}
}
\section{Silence notches}{

For the \code{plot()} routine, \verb{Notch went outside hinges} message
is often triggered by \pkg{ggplot2}. This can be silenced by
setting global options:

\code{options(rlib_message_verbosity = "quiet")}
}

\examples{
data <- wranglr::simdata

# Setup response variable
data$class_response <- as.factor(data$class_response)
mt  <- model_type_lr("class_response")
sm  <- search_type_forward_model("Forward Selection Algorithm", 10L)
ft  <- head(helpr:::get_analytes(data))  # select candidate features
mcp <- feature_selection(data,
                         candidate_features = ft,
                         model_type = mt,
                         search_type = sm,
                         cost = "AUC",
                         runs = 4L, folds = 3L,
                         random_seed = 101L)

fs <- Search(mcp)
fs

plot(fs)

# Using parallel processing:
#   should be ~4x faster than above
\dontrun{
  fs <- Search(mcp, num_cores = 4L)
}
}
\seealso{
\code{\link[=feature_selection]{feature_selection()}}
}
\author{
Stu Field, Kirk DeLisle
}
